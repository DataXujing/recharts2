#' Set \code{x|yAxis} of Echarts (Primary or Secondary)
#'
#' When an echart object is generated, you can modify it by setting axis using
#' \code{\link{\%>\%}}. \cr \cr
#' You can use work functions \code{setXAxis}, \code{setYAxis}, \code{setX1Axis},
#' \code{setY1Axis}. \cr \cr
#' This function modified a few default options for the axis component in
#' ECharts:
#' \enumerate{
#'  \item \code{scale = TRUE} (was \code{FALSE} by default in ECharts);
#'  \item \code{axisLine$onZero = FALSE} (was \code{TRUE} in ECharts).
#' }
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param series Which series to be put on this axis. Could be:
#' \itemize{
#'  \item series names, in vectors. E.g, \code{c('setosa', 'virginica')};
#'  \item index of series, in vectors. E.g., \code{1:2} or \code{c(1,3)}.
#' }
#' @param which Which axis to be modified. Could be one of the following:
#' \describe{
#'  \item{x}{primary x axis}
#'  \item{y}{primary y axis}
#'  \item{x1}{secondary x axis}
#'  \item{y1}{secondary y axis}
#' }
#' @param type Type of the axis. Could be \code{c('time', 'value', 'category', 'log')}.
#' Default 'value'.
#' @param show Logical, whether to show this axis. Default TRUE.
#' @param position Position of this axis. Could be \code{c('bottom', 'top', 'left',
#' 'right')} (default for primary x axis, secondary x axis, primary y axis and secondary
#' y axis, respectively.)
#' @param name Name of this axis. Default not set ("").
#' @param nameLocation Axis name location. Could be \code{c('end', 'start')}. Default
#' 'end'.
#' @param nameTextStyle Axis name text style. Could be a list of \code{textStyle}
#' features. Default following textStyle global settings.
#' @param boundaryGap A two-element numeric vector, defining the policy of the space
#' at the two ends of the axis (percents). Deafult \code{c(0, 0)}.
#' @param min The mininum value of the axis. Default NULL (automatic). If a numeric
#' value is set, \code{boundaryGap} is disabled.
#' @param max The maxinum value of the axis. Default NULL (automatic). If a numeric
#' value is set, \code{boundaryGap} is disabled.
#' @param scale Logical, for axis of 'value', 'time', 'log' type, to define whether
#' zoom the scale to the range between _min and _max. Default TRUE.
#' @param splitNumber Numeric, how many sections to devide the axis. Default NULL,
#' automatically deviding based on algorithms of \code{min} and \code{max}.
#' @param axisLine A list. Default: \cr
#' \code{list(show=TRUE, onZero=FALSE, lineStyle=list( \cr
#' type='solid', color='#48b', width=2, shadowColor='rgba(0,0,0,0)', shadowBlur=5,
#' shadowOffsetX=3, shadowOffsetY=3))} \cr \cr
#' \code{lineStyle} accepts features \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}
#' @param axisTick A list. Default: \cr
#' \code{show=FALSE, inside=FALSE, length=5, lineStyle=list(color="#333", width=1)} \cr \cr
#' \code{lineStyle} accepts feature \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}
#' @param axisLabel A list controlling the axis labels. Default \code{show=TRUE,
#' rotate=0, margin=8, clickable=FALSE, formatter=NULL, textStyle=list(color="#333")} \cr \cr
#' \code{textStyle} accepts features \code{color, align, baseline, fontFamily, fontSize,
#' fontStyle, fontWeight}. \cr \cr
#' \strong{\code{formatter}}:
#' \describe{
#'  \item{sprintf/format string}{String to overide \code{axisLable$formatter}.
#'  It accepts \code{sprintf} (category and value) and \code{strptime} (time) formats.}
#'  \item{js mode}{a JS function/expression, which is default}
#' } \cr
#' \code{axisLabel=list(formatter="\%s cm")} is equal to \cr
#' \code{axisLabel=list(formatter=JS('function (value) {return value + "cm";}'))} or \cr
#' \code{axisLabel=list(formatter='{value} cm')}
#' @param splitLine A list controlling the split lines. Default \code{show=TRUE,
#' lineStyle=list(color=list("#ccc"), width=1, type="solid")} \cr \cr
#' \code{lineStyle} accepts features \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}.
#' @param splitArea A list controlling the split areas. Default \code{show=FALSE,
#' onGap=NULL, areaStyle= list(color= list("rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)")
#' , type="default"} \cr \cr
#' \code{areaStyle} accepts features \code{color, type}.
#' @param data A character vector/list for axis of type 'category', to define the text
#' labels shown in this axis. Default NULL. You can even pass in a complicated list with
#' \code{textSytle} list: \cr
#' \code{list('Jan', 'Feb', 'Mar', \cr list(value='Apr', textStyle=list(color='red', ...)),
#' \cr 'May', ...)}
#'
#' @export
#' @seealso \code{\link{setXAxis}}, \code{\link{setYAxis}}, \code{\link{setX1Axis}},
#' \code{\link{setY1Axis}}
#' @references
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#tooltip-line1~xAxis-i}
#'
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#tooltip-line1~yAxis-i}
#' @examples
#' \dontrun{
#' g = echart(iris, Sepal.Width, Petal.Width, series=Species)
#'
#' # Change the style
#' g %>% setTheme('gray') %>% setXAxis(splitLine=list(show=FALSE)) %>%
#'       setYAxis(axisLine=list(lineStyle=list(width=0)))
#'
#' # Dual-yAxis, series 1,2 on primary y-axis, series 3 on secondary y-axis
#' g %>% setYAxis(1:2, name="setosa/versicolor") %>%
#'       setY1Axis("virginica", name="virginica")
#' }
setAxis = function(
    chart, series = NULL, grid = NULL, which = c('x', 'y', 'x1', 'y1'),
    type = c('value', 'category', 'time', 'log'),
    position = c('bottom', 'top', 'left', 'right'), inverse = FALSE,
    name = '', nameLocation = c('end', 'middle', 'start'),
    nameTextStyle = emptyList(), nameGap = 15, nameRotate = NULL,
    boundaryGap = c(0, 0), min = NULL, max = NULL, scale = TRUE, splitNumber = NULL,
    interval = NULL, logBase = 10, silent = FALSE, triggerEvent = FALSE,
    axisLine = list(show = TRUE, onZero = FALSE), axisTick = list(show = FALSE),
    axisLabel = list(show = TRUE), splitLine = list(show = TRUE),
    splitArea = list(show = FALSE), data = list(), zlevel = 0, z = 0
) {
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    which = match.arg(which)
    axIdx = ifna(as.integer(substr(which, 2, 3)), 0)  # 0: main ax, 1: sub ax
    which = substr(which, 0, 1)  # x or y axis
    hasT = "timeline" %in% names(chart$x)
    allSeries = getSeriesPart(chart, 'category', drop=FALSE, fetch.all=TRUE)  # all levels of series
    if (!hasT) allSeries = as.matrix(allSeries, ncol=1)
    uniSeries = unique(as.vector(allSeries))
    if (!is.null(allSeries) && !is.null(series)){
        if (is.numeric(series)){
            series = intersect(series, seq_len(nrow(allSeries)))
            series = if (length(series) > 0) allSeries[series,1] else NULL
        }else{
            series = intersect(as.character(series), unique(as.vector(allSeries)))
            if (length(series) == 0) series = NULL
        }
    }else{
        series = NULL
    }
    # get intersect of the series

    # if data partially on main axis, the rest on sub axis
    series1 = NULL
    if (length(series) > 0 && length(series) < length(uniSeries) && axIdx == 1)
        series1 = uniSeries[! uniSeries %in% series]

    # original data along the axis
    if (hasT){
        odata = lapply(chart$x$options, getMeta)
        if (!is.null(series)) {
            sdata = lapply(odata, function(lst) lst['series'])
            sdata = do.call('rbind', sdata)[,1]
        }
        odata = lapply(odata, function(lst) lst[[which]])
        odata = do.call('rbind', odata)[,1]
    }else{
        odata = getMeta(chart)[[which]][,1]
        if (!is.null(series)) sdata = getMeta(chart)[['series']][,1]
    }
    if (!is.null(series)) {
        odata1 = odata[! sdata %in% series]
        odata = odata[sdata %in% series]
    }
    # only get odata of specific series

    if (missing(type)) type = axisType(odata, which)
    if (missing(position)) {
        if (which == 'x') {
            position = if (axIdx == 0) 'bottom' else 'top'
        }else{
            position = if (axIdx == 0) 'left' else 'right'
        }
    }
    if (position %in% c('bottom', 'top'))
        position1 = c('bottom', 'top')[c('bottom', 'top') != position]
    if (position %in% c('left', 'right'))
        position1 = c('left', 'right')[c('left', 'right') != position]
    data1 = list()
    if (missing(data) && type == 'category') {
        data = unique(odata)
        #data = I(levels(as.factor(odata)))
        if (!is.null(series1))
            #data1 = I(levels(as.factor(odata1)))
            data1 = unique(odata1)
    }

    if (!is.null(axisLabel$formatter))
        if (!is.list(axisLabel$formatter)){
            axisLabel = mergeList(axisLabel, list(
                formatter=if (inherits(axisLabel$formatter, 'JS_EVAL'))
                    axisLabel$formatter else convFormat2JS(axisLabel$formatter, type))
            )
        }

    if (hasT) x = chart$x$options[[1]] else x = chart$x
    i = paste0(which, 'Axis')
    o = list(
        type = match.arg(type), show = show, position = match.arg(position),
        name = name, nameLocation = match.arg(nameLocation), nameTextStyle = nameTextStyle,
        boundaryGap = boundaryGap, min = min, max = max, scale = scale,
        splitNumber = splitNumber, axisLine = axisLine, axisTick = axisTick,
        axisLabel = axisLabel, splitLine = splitLine, splitArea = splitArea, data = data
    )
    if (!is.null(series1))
        o1 = list(
            type = match.arg(type), show = show, position = position1, #name = name,
            nameLocation = match.arg(nameLocation),
            nameTextStyle = nameTextStyle, boundaryGap = boundaryGap, min = min,
            max = max, scale = scale, splitNumber = splitNumber, axisLine = axisLine,
            axisTick = axisTick, axisLabel = axisLabel, splitLine = splitLine,
            splitArea = splitArea, data = data1
        )
    if (length(x[[i]]) > 0) {
        # only merge the arguments that are not missing, e.g. eAxis(min = 0) will
        # only overide 'min' but will not overide the 'name' attribute
        a = intersect(names(as.list(match.call()[-1])), names(o))
        if (!is.null(series1))
            a1 = intersect(names(as.list(match.call()[-1])), names(o1))
        if (length(x[[i]]) < 2 && axIdx == 1)
            x[[i]][[axIdx+1]] = mergeList(list(), o)
        x[[i]][[axIdx+1]] = mergeList(x[[i]][[axIdx+1]], o[a])

        if (!is.null(series1))
            x[[i]][[2-axIdx]] = mergeList(x[[i]][[2-axIdx]], o1[a1])
    } else {
        x[[i]][[axIdx+1]] = list()
        x[[i]][[axIdx+1]] = mergeList(x[[i]][[axIdx+1]], o)
        if (!is.null(series1)){
            if (length(x[[i]][[2-axIdx]]) == 0) x[[i]][[2-axIdx]] = list()
            x[[i]][[2-axIdx]] = mergeList(x[[i]][[2-axIdx]], o1)
        }
    }
    if (hasT) chart$x$options[[1]] = x else chart$x = x

    # revise axisIndex
    ax = paste0(which, "AxisIndex")
    if (!is.null(series1)){
        if (axIdx == 0) seriesAx1 = series1 else seriesAx1 = series
        if (hasT){
            for (i in 1:length(chart$x$options)){
                seriesAx1 = which(allSeries[,i] %in% seriesAx1)
                for (j in seriesAx1) chart$x$options[[i]]$series[[j]][[ax]] = 1
            }
        }else{
            seriesAx1 = which(allSeries[,1] %in% seriesAx1)
            for (j in seriesAx1) chart$x$series[[j]][[ax]] = 1
        }
    }

    return(chart)
}

#' @export
#' @rdname setAxis
setYAxis = function(chart, ...) {  # set primary y axis
    setAxis(chart, which = 'y', ...)
}

#' @export
#' @rdname setAxis
setY1Axis = function(chart, ...) {  # set secondary y axis
    setAxis(chart, which = 'y1', ...)
}

#' @export
#' @rdname setAxis
setXAxis = function(chart, ...) {  # set primary x axis
    setAxis(chart, which = 'x', ...)
}

#' @export
#' @rdname setAxis
setX1Axis = function(chart, ...) {  # set secondary x axis
    setAxis(chart, which = 'x1', ...)
}

axisType = function(data, which = c('x', 'y')) {
    if (is.numeric(data) || is.null(data)) return('value')
    if (is.factor(data) || is.character(data)) return('category')
    if (inherits(data, c('Date', 'POSIXct', 'POSIXlt'))) return('time')
    message('The structure of the ', which, ' variable:')
    str(data)
    stop('Unable to derive the axis type automatically from the ', which, ' variable')
}

flipAxis = function(chart, flip=TRUE, ...){
    # flip x|y-axis
    if (!flip) return(chart)
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    hasT = 'timeline' %in% names(chart$x)
    if (hasT){
        if ('xAxis' %in% names(chart$x$options[[1]]) &&
            'yAxis' %in% names(chart$x$options[[1]])) {
            axes = exchange(chart$x$options[[1]]$xAxis,
                            chart$x$options[[1]]$yAxis)
            chart$x$options[[1]]$xAxis = axes[[1]]
            chart$x$options[[1]]$yAxis = axes[[2]]
        }
    }else{
        if ('xAxis' %in% names(chart$x) &&
            'yAxis' %in% names(chart$x)){
            axes = exchange(chart$x$xAxis, chart$x$yAxis)
            chart$x$xAxis = axes[[1]]
            chart$x$yAxis = axes[[2]]
        }
    }
    return(chart %>% reElementId())
}


#' Set \code{grid} of Echarts Widgets And Pane
#'
#' When an echart object is generated, you can modify it by setting grid using
#' \code{\link{\%>\%}}. \cr
#' \strong{It is recommended to put \code{setGrid} at the end of the piped command.} \cr
#' When used for 'pane', it is only applicable for \code{scatter, point, bubble,
#' line, area, bar, histogram}. When used for 'timeline', it only take in params
#' \code{x, y, x2, y2}. When used for 'legend', 'title', 'dataZoom', 'dataRange',
#'  'toolbox', 'roamController', it only takes in params \code{x, y}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param widget Widget name to set. Could be \code{c('pane', 'timeline', 'legend',
#' 'title', 'dataZoom', 'dataRange', 'toolbox', 'roamController')}.
#' \describe{
#' \item{pane}{the area pane, takes in all the parameters}
#' \item{timeline}{timeline widget, only use \code{x, y, x2, y2}}
#' \item{legend, title, dataZoom, dataRange, toolbox, roamController}{other widgets,
#' only use \code{x, y}}
#' }
#' @param x x coordinate of the left upper point of the plot area. Default 80px.
#' @param y y coordinate of the left upper point of the plot area. Default 60px.
#' @param x2 x coordinate of the right lower point of the plot area. Default 80px.
#' @param y2 y coordinate of the right lower point of the plot area. Default 60px.
#' @param width Width of the plot area. Default NULL (automatically configured)
#' @param height Height of the plot area. Default NULL (automatically configured)
#' @param bgColor background color of plot area. Default transparent ('rgba(0,0,0,0)').
#' @param borderColor border color of the plot area. Default '#ccc'.
#' @param borderWidth border width of the plot area. Default 0px (not shown).
#' @param ... Elipsis.
#'
#' @return A modified echarts object
#' @export
#' @seealso \code{\link{relocWidget}}
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~grid}
#' @examples
#' \dontrun{
#' g = iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species)
#' g %>% setGrid(x=40, y=40, x2=70, y2=30, bgColor='gray90')
#' }
setGrid = function(chart, x=80, y=60, x2=80, y2=60, width=NULL, height=NULL,
                   bgColor=NULL, borderColor=NULL, borderWidth=1,
                   widget=c('pane', 'timeline', 'legend', 'title', 'dataZoom',
                            'dataRange', 'toolbox', 'roamController'), ...){
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    hasT = 'timeline' %in% names(chart$x)
    types = getSeriesPart(chart, 'type')
    widget = match.arg(widget)
    if (widget == 'pane') widget = 'grid'
    lstGrid = list()
    if (! missing(x)) lstGrid[['x']] = unname(x)
    if (! missing(y)) lstGrid[['y']] = unname(y)
    if (widget %in% c('grid', 'timeline')){
        if (! missing(x2)) lstGrid[['x2']] = unname(x2)
        if (! missing(y2)) lstGrid[['y2']] = unname(y2)
    }
    if (widget == 'grid'){
        if (! missing(width)) lstGrid[['width']] = width
        if (! missing(height)) lstGrid[['height']] = height
        if (! missing(borderWidth)) lstGrid[['borderWidth']] = borderWidth
        if (! missing(borderColor)) lstGrid[['borderColor']] = borderColor
        if (! missing(bgColor)) lstGrid[['backgroundColor']] = getColors(bgColor)[1]
    }
    ## wrap up
    if (hasT){
        if (widget == 'timeline'){
            chart$x$timeline = mergeList(chart$x$timeline, lstGrid)
        }else if((widget == 'grid') ||
                 widget %in% names(chart$x$options[[1]])){
            chart$x$options[[1]][[widget]] <-
                if (is.null(chart$x$options[[1]][[widget]])) lstGrid else
                    mergeList(chart$x$options[[1]][[widget]], lstGrid)
        }
    }else{
        if ((widget == 'grid') ||
            widget %in% names(chart$x))
            chart$x[[widget]] = if (is.null(chart$x[[widget]]))
                lstGrid else mergeList(chart$x[[widget]], lstGrid)
    }

    return(chart %>% reElementId())
}


#' @export
#' @rdname setGrid
relocTitle = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='title', ...)
}

#' @export
#' @rdname setGrid
relocLegend = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='legend', ...)
}

#' @export
#' @rdname setGrid
relocDataZoom = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='dataZoom', ...)
}

#' @export
#' @rdname setGrid
relocDataRange = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='dataRange', ...)
}

#' @export
#' @rdname setGrid
relocTimeline = function(chart, x=NULL, y=NULL, x2=NULL, y2=NULL, ...){
    setGrid(chart, x=x, y=y, x2=x2, y2=y2, widget='timeline', ...)
}

#' @export
#' @rdname setGrid
relocToolbox = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='toolbox', ...)
}

#' @export
#' @rdname setGrid
relocRoam = function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='roamController', ...)
}

#' Re-locate Echarts Widgets (Position of Upper-left/Lower-right Point)
#'
#' @param chart Echarts object
#' @param widgets Vector or list, could be \code{'title', 'timeline', 'legend', 'toolbox',
#' 'dataRange', 'dataZoom', 'roamController'}
#' @param x Vector, x-coordinates of the widgets' upper-left point
#' @param y Vector, y-coordinates of the widgets' upper-left point
#' @param x2 Vector, x-coordinates of the widgets' lower-right point
#' @param y2 Vector, y-coordinates of the widgets' lower-right point
#' @note If \code{x, y, x2, y2} are shorter in length than the list \code{widgets},
#' the last element of \code{x, y, x2, y2} will be applied to cover the rest.
#' If \code{x, y, x2, y2} are longer in length than the list \code{widgets},
#' the redundent elements will be dropped.
#' @return A modified Echarts object
#' @export
#' @seealso \code{\link{setGrid}}
#' @examples
#' \dontrun{
#' g = echartR(iris, Sepal.Width, Petal.Width) %>% setDataZoom()
#' g %>% relocWidgets('dataZoom', x=150)
#' }
relocWidget = function(chart, widgets, x=NULL, y=NULL, x2=NULL, y2=NULL){
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    stopifnot(all(widgets %in% c('title', 'timeline', 'legend', 'toolbox',
                                 'dataRange', 'dataZoom', 'roamController')))
    if (!missing(x)) if (!is.null(x)) x = if (length(x) < length(widgets))
        c(x, rep(x[length(x)], length(widgets) - length(x))) else x[length(widgets)]
    if (!missing(y)) if (!is.null(y)) y = if (length(y) < length(widgets))
        c(y, rep(y[length(y)], length(widgets) - length(y))) else x[length(widgets)]
    if (!missing(x2)) if (!is.null(x2)) x = if (length(x2) < length(widgets))
        c(x2, rep(x2[length(x2)], length(widgets) - length(x2))) else x[length(widgets)]
    if (!missing(y2)) if (!is.null(y2)) x = if (length(y2) < length(widgets))
        c(y2, rep(y2[length(y2)], length(widgets) - length(y2))) else x[length(widgets)]
    for (i in 1:length(widgets)){
        chart = chart %>% setGrid(x[i], y[i], x2[i], y2[i], widget=widgets[i])
    }
    return(chart %>% reElementId())
}


.getGridParam = function(chart, control, pos, size, horizontal=TRUE){
    stopifnot(length(pos) == 4)  ## x, y, x2, y2
    stopifnot(length(size) == 2) ## height, width
    hasT = 'timeline' %in% names(chart$x)
    if (hasT){
        if (control == 'timeline')  obj = chart$x$timeline
        else obj = chart$x$options[[1]][[control]]
    }else{
        obj = chart$x[[control]]
    }
    lst = lapply(c('x', 'y', 'x2', 'y2', 'orient', 'height', 'width'),
                 function(param){obj[[param]]})
    lstDefault = c(as.list(pos), ifelse(horizontal, 'horizontal', 'vertical'),
                   as.list(size))
    names(lst) = names(lstDefault) =  c('x', 'y', 'x2', 'y2', 'orient',
                                        'height', 'width')

    if (!is.null(obj))
        lst = unlist(mergeList(lstDefault, lst, keep.null=TRUE,
                               skip.merge.null=TRUE))
    # x, y , orient
    else return(rep(NA, 8))

    # x, y, x2, y2, width, height
    x = ifelse(lst['x'] %in% c('left', 'center', 'right'), lst['x'],
               ifelse(grepl("document\\.getElementById", lst['x']), 'right',
                      suppressWarnings(as.numeric(lst['x']))))
    if (is.numeric(x)) x = if (ifna(x, 0) < 80) 'left' else
        if (ifna(x, 0) < 400) 'center' else 'right'
    y = ifelse(lst['y'] %in% c('top', 'center', 'bottom'), lst['y'],
               ifelse(grepl("document\\.getElementById", lst['y']), 'bottom',
                      suppressWarnings(as.numeric(lst['y']))))
    if (is.numeric(y)) y = if (ifna(y, 0) < 60) 'top' else
        if (ifna(y, 0) < 400) 'center' else 'bottom'

    x2 = suppressWarnings(as.numeric(lst['x2']))
    y2 = suppressWarnings(as.numeric(lst['y2']))
    height = suppressWarnings(as.numeric(lst['height']))
    width = suppressWarnings(as.numeric(lst['width']))
    pos = ifelse(length(clockPos(x, y, lst['orient'])) == 0, 12,
                 clockPos(x, y, lst['orient']))

    x = suppressWarnings(as.numeric(lst['x']))
    y = suppressWarnings(as.numeric(lst['y']))
    if (is.na(x)) x = ifnull(switch(lst['x'], left=0, center=0, right=NA), 0)
    if (is.na(x2)) x2 = ifnull(switch(lst['x'], left=NA, center=0, right=0), 0)
    if (is.na(y)) y = ifnull(switch(lst['y'], top=0, center=0, bottom=NA), 0)
    if (is.na(y2)) y2 = ifnull(switch(lst['y'], top=NA, center=0, bottom=0), 0)

    return(c(pos, x, y, x2, y2, height, width, unname(lst['orient']=='horizontal')))
}



#' @export
#' @importFrom data.table data.table dcast
tuneGrid = function(chart, ...){
    # tune the grid of pane and widgets
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    types = getSeriesPart(chart, 'type')
    hasT = 'timeline' %in% names(chart$x)
    # if not Cartesian Coord chart, skip out

    controls = c('title', 'timeline', 'legend', 'toolbox', 'dataRange',
                 'dataZoom', 'roamController')
    gridParam = c('pos', 'x', 'y', 'x2', 'y2', 'height', 'width', 'orient')
    dfGrid = data.frame(matrix(ncol=length(gridParam), nrow=length(controls)))
    colnames(dfGrid) = gridParam
    rownames(dfGrid) = controls

    #---------- get x, y, x1, y1 of each control --------------
    dfGrid['title',] = .getGridParam(
        chart, 'title', c('center', 'bottom', NA, NA), c(50, 50))
    dfGrid['legend',] = .getGridParam(
        chart, 'legend', c('left', 'top', NA, NA), c(50, 50))
    dfGrid['dataRange',] = .getGridParam(
        chart, 'dataRange', c('left', 'bottom', NA, NA), c(50, 120), FALSE)
    dfGrid['dataZoom',] = .getGridParam(
        chart, 'dataZoom', c('center', 'bottom', NA, NA), c(30, 30))
    dfGrid['toolbox',] = .getGridParam(
        chart, 'toolbox', c('right', 'top', NA, NA), c(50, 50))
    dfGrid['timeline',] = .getGridParam(
        chart, 'timeline', c('center', 'bottom', 80, 0), c(50, 50))
    dfGrid['roamController',] = .getGridParam(
        chart, 'roamController', c('right', 'top', NA, NA), c(80, 150), FALSE)
    # remove all NA rows
    dfGrid = dfGrid[!(apply(dfGrid, 1, function(row) all(is.na(row)))),]

    #dfGrid <<- dfGrid
    # browser()

    sumGrid = dcast(data.table(dfGrid), orient + pos ~ ., fun=sum,
                    value.var=c("x", "y", "x2", "y2", "height", "width"))
    uniqueGrid = dfGrid[!duplicated(paste(dfGrid$orient, dfGrid$pos)),]
    uniqueGrid = uniqueGrid[order(uniqueGrid$orient, uniqueGrid$pos),]
    sumGrid[,c('x_sum_.', 'y_sum_.', 'x2_sum_.', 'y2_sum_.')] <-
        uniqueGrid[, c('x', 'y', 'x2', 'y2')]
    sumGrid$x = ifblank(
        rowSums(sumGrid[,list(x_sum_., width_sum_.)], na.rm=TRUE), NA)
    sumGrid$y = ifblank(
        rowSums(sumGrid[,list(y_sum_., height_sum_.)], na.rm=TRUE), NA)
    sumGrid$x2 = ifblank(
        rowSums(sumGrid[, list(x2_sum_., width_sum_.)], na.rm=TRUE), NA)
    sumGrid$y2 = ifblank(
        rowSums(sumGrid[, list(y2_sum_., height_sum_.)], na.rm=TRUE), NA)

    #uniqueGrid <<- uniqueGrid
    #sumGrid <<- sumGrid

    lstGrid = list()
    if (length(sumGrid[pos %in% c(8, 9, 10), x]) > 0)
        if (max(sumGrid[pos %in% c(8, 9, 10), x]) > 70)
            lstGrid$x = unname(max(ifblank(sumGrid[pos == 9, x], 70)) + 20)
    if (length(sumGrid[pos %in% c(11, 12, 1), y]) > 0)
        if (max(sumGrid[pos %in% c(11, 12, 1), y]) > 50)
            lstGrid$y = unname(max(ifblank(sumGrid[pos == 12, y], 50)) + 30)
    if (length(sumGrid[pos %in% c(2, 3, 4), x2]) > 0)
        if (max(sumGrid[pos %in% c(2, 3, 4), x2]) > 70)
            lstGrid$x2 = unname(max(ifblank(sumGrid[pos == 3, x2], 70)) + 20)
    if (length(sumGrid[pos %in% c(5, 6, 7), y2]) > 0)
        if (max(sumGrid[pos %in% c(5, 6, 7), y2]) > 50)
            lstGrid$y2 = unname(max(ifblank(sumGrid[pos == 6, y2], 50)) + 30)

    ## tune grid if there are duplicated pos
    if (any(duplicated(dfGrid$pos))){
        dupPos = table(dfGrid$pos)
        dupPos = as.numeric(names(dupPos[dupPos > 1]))
        for (i in dupPos){
            dfDupGrid = dfGrid[dfGrid$pos == i,]
            len = nrow(dfDupGrid)
            widgets = row.names(dfDupGrid)[2:len]
            widgetsNotTL = widgets[!widgets %in% 'timeline']
            dfDupGrid$cumHeight = cumsum(dfDupGrid$height)
            dfDupGrid$cumWidth = cumsum(dfDupGrid$width)
            sizeParam = ifelse(i %in% c(1, 5, 6, 7, 11, 12), 'height', 'width')

            if (i %in% c(11, 12, 1)){
                cumSize = ifna(dfDupGrid[1, 'y'],0) +
                    dfDupGrid[1: (len - 1), c("cumHeight")]
                w = 'y'
                w2 = 'y2'
            }else if (i %in% c(2, 3, 4)){
                cumSize = ifna(dfDupGrid[1, 'x2'],0) +
                    dfDupGrid[1: (len - 1), c("cumWidth")]
                w = 'x2'
                w2 = 'x'
            }else if (i %in% c(5, 6, 7)){
                cumSize = ifna(dfDupGrid[1, 'y2'],0) +
                    dfDupGrid[1: (len - 1), c("cumHeight")]
                w = 'y2'
                w2 = 'y'
            }else if (i %in% c(8, 9, 10)){
                cumSize = ifna(dfDupGrid[1, 'x'],0) +
                    dfDupGrid[1: (len - 1), c("cumWidth")]
                w = 'x'
                w2 = 'x2'
            }

            names(cumSize) = widgets

            if (hasT){
                for (j in widgets){
                    if (j == 'timeline') chart$x[[j]][[w]] = unname(cumSize[j])
                    else {
                        chart$x$options[[1]][[j]][[w]] = unname(cumSize[j])
                        if (w %in% c('x2', 'y2'))
                            #      chart$x$options[[1]][[j]][[w2]] =
                            #          dev.size('px')[ifelse(w == 'x2', 1, 2)] - 10 -
                            #          dfGrid[j, sizeParam] - chart$x$options[[1]][[j]][[w]]
                            chart$x$options[[1]][[j]][[w2]] = JS(
                                paste0(getJSElementSize(
                                    chart, ifelse(w == 'x2', 'width', "height")),
                                    " - ", dfGrid[j, sizeParam] +
                                        chart$x$options[[1]][[j]][[w]]))
                    }
                }
            }else{
                for (j in widgets) {
                    chart$x[[j]][[w]] = unname(cumSize[j])
                    if (w %in% c('x2', 'y2'))
                        # chart$x[[j]][[w2]] =
                        #     dev.size('px')[ifelse(w == 'x2', 1, 2)] - 10 -
                        #     dfGrid[j, sizeParam] - chart$x[[j]][[w]]
                        chart$x[[j]][[w2]] = JS(
                            paste0(getJSElementSize(
                                chart, ifelse(w == 'x2', 'width', "height")),
                                " - ", dfGrid[j, sizeParam] +
                                    chart$x[[j]][[w]]))
                }
            }
        }
    }

    ## additional tuning
    if ('dataZoom' %in% row.names(dfGrid))
        if (dfGrid['dataZoom', 'orient'] == 1){
            if (hasT) chart$x$options[[1]]$dataZoom$x = ifnull(lstGrid$x, 80)
            else chart$x$dataZoom$x = ifnull(lstGrid$x, 80)
        }else{
            if (hasT) chart$x$options[[1]]$dataZoom$y = ifnull(lstGrid$y, 60)
            else chart$x$dataZoom$y = ifnull(lstGrid$y, 60)
        }
    if ('timeline' %in% row.names(dfGrid)){
        chart$x$timeline$x = ifnull(lstGrid$x, 80)
        chart$x$timeline$x2 = ifnull(lstGrid$x2, 80)
    }

    ## wrap up
    # collect all grid features
    if (all(types %in% c('scatter', 'line', 'bar', 'k', 'eventRiver')))
        if (length(lstGrid) > 0){
            if (hasT)
                chart$x$options[[1]][['grid']] = lstGrid
            else
                chart$x[['grid']] = lstGrid
        }
    return(chart %>% reElementId())
}


autoPolar = function(chart, type){
    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    chartTypes = getSeriesPart(chart, 'type')
    hasT = 'timeline' %in% names(chart$x)
    if (!all(chartTypes %in% c('radar'))) return(chart)

    # get chart meta data
    hasT = 'timeline' %in% names(chart$x)
    if (hasT){
        data = lapply(chart$x$options, function(l) getMeta(l))
        list.names = names(data[[1]])
        data = lapply(list.names, function(v) {
            do.call('rbind', lapply(data, function(l) l[[v]]))
        })
        names(data) = list.names
    }else data = getMeta(chart)
    dt = data.frame(x=data$x[,1], y=data$y[,1])
    dt$idx = if (is.null(data$series)) 1 else data$series[,1]
    index = as.character(unique(dt$idx))
    dt$series = if (ncol(data$x) == 1) names(data$y)[1] else data$x[,2]
    if (!is.null(data$t)) {
        dt$t = data$t[,1]
        dt = data.table::dcast(dt, idx + x + series + t ~., sum, value.var='y')
        names(dt) = c('idx', 'x', 'series', 't', 'y')
    }else{
        dt = data.table::dcast(dt, idx + x + series ~., sum, value.var='y')
        names(dt) = c('idx', 'x', 'series', 'y')
    }

    # layout
    layouts = autoMultiPolarChartLayout(length(index), gap=1.5)
    rows = layouts$rows
    cols = layouts$cols
    centers = layouts$centers
    rownames(centers) = index
    radius = layouts$radius

    # build polar lists
    obj = lapply(index, function(i){
        dat = dt[dt$idx == i,]
        o = list(center=paste0(centers[i, 1:2], '%'), radius=paste0(radius, '%'))
        indicator = lapply(as.character(unique(dat$x)), function(x){
            list(text=x, max=ifna(max(unname(dt[dt$x==x, 'y'])), 0) * 1.2)
        })
        o[['indicator']] = indicator
        if (grepl('circle', type[which(index == i), 'misc']))
            o[['type']] = 'circle'
        return(o)
    })

    if (hasT){
        chart$x$options[[1]][['polar']] = obj
    }else{
        chart$x[['polar']] = obj
    }

    return(chart %>% reElementId())
}

#' Set \code{polar} of Echarts (For Radar Charts)
#'
#' Set the \code{polar} coordinates of Echarts for radar charts.  \cr
#' When an echart object is generated, you can modify it by setting aesthetics using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{
#' \link{echartR}}
#' @param polarIndex Integer vector. The index of the polar systems you want to set.
#' Default NULL.
#' @param center Vector of the x, y position of the polar center. Could be numeric
#' or character (percent form) vectors of length 2. Default c('50\%', '50\%').
#' @param radius The radius of the polar system, could be numeric or character (percent form).
#' Default '75\%'.
#' @param startAngle Numeric (-180 ~ 180). The start angle. Default 90.
#' @param splitNumber Numeric. The number of sections to divide. Default 5.
#' @param boundaryGap Numeric vector of length 2. The gapping policy of the axis.
#' Default c(0, 0).
#' @param scale Logical. Whether to ignore zero and zoom toward the range of _min and _max.
#' @param axisLine List. Axis line styles. You can set its \code{show, onZero, lineStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param axisLabel List. Axis label styles. You can set its \code{show, rotate, margin,
#' clickable, formatter, textStyle} features. Default \code{list(show=FALSE)}.
#' @param splitLine List. Split line styles. You can set its \code{show, lineStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param splitArea List. Split area styles. You can set its \code{show, onGap, areaStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param type Character, 'polygon' or 'circle'. The type of the polar shape.
#' Default 'polygon'.
#' @param indicator List. The radar indicator and labels. The basic structure is \code{
#' list(list(text='...', min=..., max=..., axisLabel=list(...)), list(text='...', min=..., max=...),
#' list(...), ...)}. Default is empty.
#' @param axisName List. The name of the axis. You can set its \code{show, formatter,
#' textStyle} features. Default \code{list(show=TRUE, formatter=NULL, textStyle=
#' list(color='#333'))}.
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~polar}
#' @examples
#' \dontrun{
#' cars = mtcars[c('Merc 450SE','Merc 450SL','Merc 450SLC'),
#'               c('mpg','disp','hp','qsec','wt','drat')]
#' cars$model = rownames(cars)
#' cars = data.table::melt(cars, id.vars='model')
#' names(cars) = c('model', 'indicator', 'Parameter')
#' g = echartr(cars, indicator, Parameter, model, type='radar') %>%
#'          setTitle('Merc 450SE  vs  450SL  vs  450SLC')
#' g %>% setPolar(c(1,3), type='circle') %>%
#'       setPolar(2, splitArea=list(show=FALSE)) %>%
#'       setPolar(3, axisName=list(textStyle=textStyle(color='red')))
#' }
#'
setPolar = function(chart, polarIndex=NULL, center=c('50%', '50%'), radius='75%',
                    startAngle=90, splitNumber=5, boundaryGap=c(0, 0),
                    scale=FALSE, axisLine=NULL, axisLabel=NULL, splitLine=NULL,
                    splitArea=NULL, type=c('polygon', 'circle'),
                    indicator=NULL, axisName=NULL,
                    ...){

    if (!inherits(chart, 'echarts'))
        stop('chart is not an Echarts object. ',
             'Check if you have missed a %>% in your pipe chain.')
    chartTypes = getSeriesPart(chart, 'type')
    if (!all(chartTypes=='radar')) return(chart)

    hasT = 'timeline' %in% names(chart$x)
    if (hasT){
        nIndex = length(chart$x$options[[1]]$series)
    }else{
        nIndex = length(chart$x$series)
    }

    if (is.null(polarIndex)) polarIndex = 1:nIndex else
        if (!all(data.table::between(polarIndex, 1, nIndex)))
            stop(paste('polarIndex is not valid. It should all be between 1 and', nIndex))

    lstPolar = list()
    if (!missing(center)) lstPolar[['center']] = center
    if (!missing(radius)) lstPolar[['radius']] = radius
    if (!missing(startAngle)) lstPolar[['startAngle']] = startAngle
    if (!missing(splitNumber)) lstPolar[['splitNumber']] = splitNumber
    if (!missing(boundaryGap)) lstPolar[['boundaryGap']] = boundaryGap
    if (!missing(scale)) lstPolar[['scale']] = scale
    if (!missing(axisLine)) lstPolar[['axisLine']] = axisLine
    if (!missing(axisLabel)) lstPolar[['axisLabel']] = axisLabel
    if (!missing(splitLine)) lstPolar[['splitLine']] = splitLine
    if (!missing(splitArea)) lstPolar[['splitArea']] = splitArea
    type = match.arg(type)
    if (type != 'polygon') lstPolar[['type']] = type
    if (!missing(indicator)) lstPolar[['indicator']] = indicator
    if (!missing(axisName)) lstPolar[['name']] = axisName

    for (i in polarIndex){
        if (hasT){
            chart$x$options[[1]]$polar[[i]] = mergeList(
                chart$x$options[[1]]$polar[[i]], lstPolar)
        }else{
            chart$x$polar[[i]] = mergeList(
                chart$x$polar[[i]], lstPolar)
        }
    }

    return(chart %>% reElementId())
}

